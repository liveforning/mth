
# 01、Linux系统的文件目录结构

  目录结构：

```Bash
Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。

Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要**挂载（类似windows下的分配盘符）**。

Etc：该目录主要存储一些配置文件。

Home：表示“家”，表示**除了root用户以外其他用户的家目录**，类似于windows下的User/用户目录。

Proc：process，表示进程，该目录中存储的是Linux运行时候的进程。

Root：该目录是root用户自己的家目录。

Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。

Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。

Usr：存放的是用户自己安装的软件。类似于windows下的program files。tu

Var：存放的程序/系统的日志文件的目录。

**Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。**
```

# 02、Linux的基本指令

## 一、指令与选项

什么是Linux的指令？

指在Linux终端（命令行）中输入的内容就称之为指令。一个完整的指令的标准格式：Linux通用的格式

**指令主体****（空格）**** [选项]****（空格）**** [操作对象]**

一个指令可以包含多个选项，操作对象也可以是多个

## 二、基础指令

### 1、ls指令

含义：ls （list）

**用法1：#ls**

含义：列出当前工作目录下的所有文件/文件夹的名称

```Bash
ls
```

**用法2：#ls 路径**

含义：列出指定路径下的所有文件/文件夹的名称
　　关于路径（重要）：
　　路径可以分为两种：相对路径、绝对路径。
　　相对路径：相对首先得有一个参照物（一般就是当前的工作路径）；
　　相对路径的写法：在相对路径中通常会用到2个符号“./”【表示当前目录下】、“../”【上一级目录下】。
　　绝对路径：绝对路径不需要参照物，直接从根“/”开始寻找对应路径；



**用法3：#ls 选项 路径**

含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。

```Bash
 ls -l
 ls -la
 ls -ltr
```

常见的语法：
　　#ls -l 路径
　　#ls -la 路径
　　选项解释：
　　**-l：表示list，表示以详细列表的形式进行展示**
　　**-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）**
　　**“-”表示改行对应的文档类型为文件，“d”表示文档类型为文件夹,在Linux中隐藏文档一般都是以“.”开头。**
　　**用法4：#ls -lh 路径**
　　含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以**可读性较高的形式显示**

### 2、pwd指令

**用法：#pwd		（print working directory，打印当前工作目录）**

```Bash
pwd
```

### 3、cd指令

命令：#cd（change directory，改变目录）
　　作用：用于切换当前的工作目录的
　　**语法：#cd 路径**
　　案例：当前在“/”下，需要使用绝对路径切换到/usr/local。

```Bash
cd /usr/local
```

案例：当前在/usr/local下，需要使用相对路径切换目录到home目录下的Linux123用户家目录中去。

```Bash
cd ../../honme/Linux123
```

补充：
　　在Linux中有一个特殊的符号“~”，表示当前用户的家目录。
　　切换的方式：

```Bash
cd ~
```

### 4、mkdir指令

指令：mkdir    （make directory，创建目录）
　　语法1：**#mkdir 路径 【路径，可以是文件夹名称也可以是包含名称的一个完整路径】**



案例：在当前路径下创建出目录“yunweihenniux”

```Bash
mkdir yunweihenniux
```

注意：ls列出的结果颜色说明，**其中蓝色的名称表示文件夹**，黑色的表示文件，**绿色的其权限为拥有所有权限**。



案例：在指定路径下创建出一个文件夹“yunweihenniux”

```Bash
mkdir /root/yunweihenniux
```

语法2：**#mkdir -p 路径**
　　含义：**当一次性创建多层不存在的目录的时候**，添加-p参数，否则会报错

```Bash
mkdir -p yunweihenniux/a/b/c
```

语法3：**#mkdir 路径1 路径2 路径3 …. ** 【表示一次性创建多个目录】

```Bash
mkdir a b c
```

### 5、touch指令

指令：touch
　　作用：创建文件
　　语法：**#touch 文件路径**【路径可以是直接的文件名也可以是路径】



案例：使用touch来在当前路径下创建一个文件，命名为Linux.txt

```Bash
touch Linux.txt
```

案例：使用touch来同时创建多个文件

```Bash
touch Linux1.txt Linux2.txt
```

案例：使用touch来在“Linux123”用户的家目录中创建文件，Linux.txt

```Bash
touch /home/Linux123/Linux.txt
```

### 6、cp指令

指令：cp（copy，复制）
　　作用：复制文件/文件夹到指定的位置
　　语法：**#cp 被复制的文档路径 文档被复制到的路径**
　　案例：使用cp命令将当前目录下的q文件复制到Linux123用户目录

```Bash
cp q /home/Linux123
```

**注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。**
　　案例：使用cp命令来复制一个文件夹
　　**注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】，否则目录将被忽略**

```Bash
cp -r yunweihenniux /home/Linux123
```

### 7、mv指令

指令：mv   （move，移动，剪切）
　　作用：移动文档到新的位置
　　语法：**#mv 需要移动的文档路径 需要保存的位置路径**
　　确认：移动之后原始的文件还在不在原来的位置？原始文件是不在原始位置的
　　案例：使用mv命令将文件/文件夹移动至跟目录

```Bash
mv q /
```

补充：在Linux中重命名的命令也是mv，语法和移动语法一样q文件重命名为q1。

```Bash
mv q q1
```

### 8、rm指令

指令：rm （remove，移除、删除）
　　作用：移除/删除文档
　　语法：#rm 选项 需要移除的文档路径
　　选项：
　　-f：force，强制删除，不提示是否删除
　　-r：表示递归

案例：删除一个文件

```Bash
rm -rf a b c
rm -rf Linux*
```

**注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。**
　　**注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。**
　　***称之为通配符，意思表示任意的字符，Linux*****，则表示只要文件以Linux开头，后续字符则不管.**



### 9、vim指令

指令：vim   （vim是一款文本编辑器）类似于windows的记事本
　　语法：**#vim 文件的路径**
　　作用：打开一个文件（可以不存在，也可以存在）
　　i在光标前插入  a在光标后插入   o在光标下一行行首插入   R  全部替换
　　r替换单个选中字符
　　案例：使用vim来打开文件
　　退出打开的文件：在没有按下其他命令的时候，按下shift+英文冒号，输入q，按下回车即可  先按esc退出其他模式    :wq保存并退出   :!q强制退出   :q退出

### 10、输出重定向

**一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。**
　　>：覆盖输出，会覆盖掉原先的文件内容
　　>>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加

```Bash
tail -100f log/log.xxx > 1.txt
```

**语法：#正常执行的指令 > / >> 文件的路径**
　　注意：文件可以不存在，不存在则新建



案例：使用覆盖重定向，保存ls -la 的执行结果，保存到当前目录下的ls.txt或者，使用追加重定向，保存ls -la的执行结果到ls.txt中：

```Bash
ls -la > ls.txt
ls -la >> ls.txt
```

### 11、cat指令

**作用1：cat有直接打开一个文件的功能。**
　　**语法1：#cat 文件的路径**
　　**作用2：cat还可以对文件进行合并**
　　**语法2：#cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n > 合并之后的文件路径**
　　例如，合并3个文件，并存到一个文件中【配合输出重定向使用】

```Bash
cat q
cat /home/mth/a home/mth/b > home/mth/c
```

## 三、进阶指令（重点）

### 1、df指令

作用：查看磁盘的空间
　　**语法：#df -h-h表示以可读性较高的形式展示大小**

```Bash
df -h
```

### 2、free指令

作用：查看内存使用情况
　　**语法：#free -m   -m表示以mb为单位查看  -k  KB   -g   GB**

```Bash
free -m
```

free：剩余的真实可以用的内存。
　　Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。

### 3、head指令

作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。
　　**语法：#head -n 文件路径   【n表示数字】**

```Bash
head -5 a.txt
```

### 4、tail指令

作用1：查看一个文件的末n行，如果n不指定默认显示后10行
　　**语法：#tail -n 文件的路径    n同样表示数字**

```Bash
tail -5 a.txt
```

作用2：可以通过tail指令来查看一个文件的动态变化内容【**变化的内容不能是用户手动增加的**】
　　**语法：#tail -f 文件路径   结束tail    Ctrl+C**
　　**该命令一般用于查看系统的日志比较多。**

```Bash
tail -100f log/log.xxx
```

### 5、less指令

作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、**空格键**+上下方向键）查看更多
　　**语法：#less 需要查看的文件路径   退出  q   quit   d翻页**
　　**less  -e  查看到文件末尾自动退出  -N  显示行号   **

```Bash
less -eN q.txt
```

在退出的只需要按下q键即可。

### 6、wc指令

作用：统计文件内容信息（包含行数、单词数、字节数）
　　语法：**#wc -lwc 需要统计的文件路径**
　　**-l：表示lines，行数**
　　-w：表示words，单词数   依照空格来判断单词数量
　　-c：表示bytes，字节数

```Bash
wc -lwc
```

### 7、date指令（重点）

作用：表示操作时间日期（**读取**、设置）
　　语法1：#date输出的形式：2018年 3月 24日 星期六 15:54:28
　　语法2：**#date  +%F（等价于#date  “+%Y-%m-%d” ）**输出形式：2018-03-24
　　语法3：#date  “+%F %T”    引号表示让“年月日与时分秒”成为一个不可分割的整体
　　**等价操作#date  “+%Y-%m-%d %H:%M:%S”  **输出的形式：2018-03-24 16:01:00

  语法4：date -s 2023-01-12 18:11:37将系统时间修改为2023-01-12 18:11:37



语法4：获取之前或者之后的某个时间（备份）-

```Bash
date  -d  "-1 day"  "+%Y-%m-%d %H:%M:%S"
```

符号的可选值：+（之后） 或者 - （之前）
　　单位的可选值：day（天）、month（月份）、year（年）
　　%F：表示完整的年月日
　　%T：表示完整的时分秒
　　%Y：表示四位年份
　　%m：表示两位月份（带前导0）
　　%d表示日期（带前导0）
　　%H：表示小时（带前导0）
　　%M：表示分钟（带前导0）
　　%S：表示秒数（带前导0）

### 8、cal指令

**作用：用来操作日历的  calender  日历**
　　**语法1：#cal  等价于 #cal  -1**直接输出当前月份的日历
　　**语法2：#cal  -3**表示输出上一个月+本月+下个月的日历
　　**语法3：#cal  -y 年份**  表示输出某一个年份的日历



### 9、clear/ctrl + L指令

作用：清除终端中已经存在的命令和结果（信息）。
　　**语法：clear或者快捷键：ctrl + L**
　　需要注意的是，该命令并不是真的清除了之前的信息，而是把之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。



### 10、管道（重要）

**管道符：|  & 取地址  $        &&   ||**
　　作用：管道一般可以用于“**过滤**”，“特殊”，“扩展处理”。
　　语法：管道不能单独使用，必须需要配合前面所讲的一些指令来一起使用，其作用**主要是辅助作用**。



**①过滤**案例（**100%使用**）：需要通过管道查询出根目录下包含“y”字母的文档名称。

```Bash
ls / | grep y

```

以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入；
　　grep指令：主要用于过滤



②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解）
　　之前通过less查看一个文件，可以#less 路径
　　现在通过管道还可以这么：

```Bash
cat 路径|less
```

③扩展处理：请使用学过的命令，来统计某个目录下的文档的总个数

```Bash
**ls / | wc -l**
```

# 03、Linux的基本指令（2）

## 一、高级指令

### 1、hostname指令



作用：操作服务器的**主机名**（**读取**、设置）
　　语法1：#hostname含义：表示输出完整的主机名
　　**语法2：#hostname  -f含义：表示输出当前主机名中的FQDN**（全限定**域名**）

```Bash
hostname  
hostname f

```

### 2、id指令



**作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。**
　　语法1：#id默认显示当前执行该命令的用户的基本信息
　　语法2：#id  用户名显示指定用户的基本信息

```Bash
id
id root
```

验证上述信息是否正确？
　　**验证用户信息：通过文件/etc/passwd**
　　**验证用户组信息：通过文件/etc/group**
　　查看系统中一共多少个用户

```Bash
cat /etc/passwd
cat /etc/group
cat  /etc/passwd|wc -l

```

### 3、whoami指令

**作用：“我是谁？”显示当前登录的用户名，****一般用于shell脚本，用于获取当前操作的用户名方便记录日志****。**

```Bash
whoami
```



### 4、ps  -ef指令（重点）

指令：ps   ps -ef | grep 进程名
　　作用：主要是查看服务器的进程信息
　　选项含义：
　　-e：等价于“-A”，表示列出全部的进程
　　-f：显示全部的列（显示全字段）

```Bash
ps -ef 
```

列的含义：
　　UID：该进程执行的用户id；
　　PID：进程id；
　　PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）；
　　C：Cpu的占用率，其形式是百分数；
　　STIME：进行的启动时间；
　　TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；
　　TIME：进程的执行时间；
　　CMD：该进程的名称或者对应的路径；



案例：（100%使用的命令）在ps的结果中过滤出想要查看的进程状态

```Bash
**ps -ef|grep 进程名称**
```

查看当前路径的所有进程

```Bash
ps -ef | grep `pwd`
```

### 5、top指令（重点）

**作用：查看cpu服务器的进程占的资源（100%使用）**
　　语法：
　　进入命令：#top（动态显示）
　　退出命令：按下q键

```Bash
topx
```

表头含义：
　　PID：进程id；
　　USER：该进程对应的用户；
　　PR：优先级；
　　VIRT：虚拟内存；
　　RES：常驻内存；
　　SHR：共享内存；
　　计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）
　　S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；
　　%CPU：表示CPU的占用百分比；
　　%MEM：表示内存的占用百分比；
　　TIME+：执行的时间；
　　COMMAND：进程的名称或者路径；
　　**在运行top的时候，可以按下方便的快捷键：**
　　M：表示将结果按照内存（MEM）从高到低进行降序排列；
　　P：表示将结果按照CPU使用率从高到低进行降序排列；
　　1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息；

### 6、du -sh指令

作用：查看目录的真实大小
　　**语法：#du -sh 目录路径**
　　选项含义：
　　-s：summaries，只显示汇总的大小
　　-h：表示以高可读性的形式进行显示



案例：统计“/root/yunweihenniux”目录的实际大小

```Bash
du -sh /root/yunweihenniux
```



### 7、find指令

作用：用于查找文件（其参数有55个之多）
　　语法：#find 路径范围 选项 选项的值 
　　选项：
　　-name：按照文档名称进行搜索（支持模糊搜索） 文件名需要加上单引号
　　-type：按照文档的类型进行搜索  find / -f  找文件   find / -d 找目录
　　文档类型：“-”表示文件（在使用find的时候需要用f来替换），“d”表示文件夹

案例：使用find来搜索httpd.conf
　　案例：搜索etc目录下所有的conf后缀文件
　　案例：使用find来搜索/etc/sane.d/目录下所有的**文件**
　　案例：使用find来搜索/etc/目录下所有的**文件夹**

```Bash
find / -name httpd.conf
find /etc -name *.conf
find /etc/sane.d/ -type f  
find /etc -type d

```

### 8、service指令（重点）

作用：用于控制一些软件的服务启动/停止/重启
　　**语法：#service 服务名 start启动/stop停止/restart重启**



例如：需要启动本机安装的Apache（网站服务器软件），其服务名httpd并通过ps命令来检查httpd服务是否启动：

```Bash
service httpd start

ps -ef | grep httpd
```



### 9、kill指令（重点）

**作用：表示杀死进程**（当遇到僵尸进程或者出于某些原因需要关闭进程的时候）
　　语法：**#kill  进程PID**（语法需要配合ps一起使用）
　　-9强制

案例：需要kill掉httpd的进程

```Bash
ps-efl grep httpd
    root 29867 1 Q 21：04 00：00：00/usr/sbin/httpd
kill -9 29867 
```



与kill命令作用相似但是比kill更加好用的杀死进程的命令：killall

```Bash
killall httpd | grep `pwd`
```

### 10、ifconfig指令（重点）



**作用：用于操作网卡相关的指令。**
　　简单语法：#ifconfig（获取网卡信息）   Linux     ipconfig(win10)



```Bash
ifconfig
```


　　**注意：inet addr就是网卡的ip地址**。

### 11、reboot指令

作用：重新启动计算机
　　**语法1：****#reboot       重启**
　　语法2：#reboot  -w   模拟重启，但是不重启（只写关机与开机的日志信息）





### 12、shutdown指令

作用：关机（慎用）
　　**语法1：#shutdown -h now“关机提示”  或者  #shutdown  -h 15:25  “关机提示”**
　　案例：设置Linux系统关机时间在12:00

```Bash
shutdown -h 12:00
```

**如果想要取消关机计划的话，则可以按照以下方式去尝试：**
　　**①针对于centos7.x之前的版本：ctrl+c**
　　**②针对于centos7.x（包含）之后的版本：#shutdown  -c**



除了shutdown关机以外，还有以下几个关机命令：

```Bash
init 0
halt
poweroff
```

### 13、uptime指令

作用：输出计算机的持续在线时间（**计算机从开机到现在运行的时间**）

```Bash
uptime
```

### 14、uname指令

作用：获取计算机操作系统相关信息
　　语法1：#uname获取操作系统的类型
　　**语法2：#uname  -aall，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划）**



```Bash
uname
uname -a

```

### 15、netstat -tnlp指令

作用：查看网络连接状态（**可以查看端口占用情况）**

```Bash
netstat -tnlp
```

选项说明：
　　-t：表示只列出tcp协议的连接；
　　-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；
　　-l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；
　　-p：表示显示发起连接的进程pid和进程名称；



### 16、man指令

作用：manual，手册（包含了Linux中全部命令手册，英文）
　　语法：#man 命令（退出按下q键）
　　案例：通过man命令查询cp指令的用法



```Bash
man cp
```

# 04、编辑器之神——vim编辑器

## 一、vi介绍

Vi编辑器是所有Unix及Linux系统下标准的编辑器，类似于windows系统下的notepad（记事本）编辑器，由于在Unix及Linux系统的任何版本，Vi编辑器是完全相同的，因此可以在其他任何介绍vi的地方都能进一步了解它，Vi也是Linux中最基本的文本编辑器，学会它后，我们将在Linux的世界里畅行无阻，**尤其是在终端中**。
　　关于vim：
　　vi和vim都是Linux中的编辑器，不同的是，**vim比较高级**，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding（写代码的）。

**Vim重点是光标的移动，模式切换，删除，查找，替换，复制，粘贴，撤销命令的使用**。

## 二、vim三种模式（重点）

Vim中存在三种模式（大众的认知）：**命令模式、编辑模式（输入模式）、来了末行模式（尾行模式）**。



命令模式：在该模式下是不能对文件直接编辑，可以输入快捷键进行一些操作（删除行，复制行，移动光标，粘贴等等）【打开文件之后默认进入的模式】；
　　编辑模式：在该模式下可以对文件的内容进行编辑；
　　末行模式：可以在末行输入命令来对文件进行操作（搜索、替换、保存、退出、撤销、高亮等等）；

Vim的打开文件的方式（4种，要求掌握的就前三种）：

       vim 文件路径作用：      打开指定的文件
　　vim  +数字  文件的路径作用：      打开指定的文件，并且将光标移动到指定行
　　vim  +/关键词  文件的路径作用：      打开指定的文件，并且高亮显示关键词
　　vim 文件路径1 文件路径2 文件路径3   作用：     同时打开多个文件

```Bash
vim a.sh
vim +5 a.sh
vim +/echo a.sh

```

## 三、命令模式

注意：该模式是打开文件的第一个看到的模式（打开文件即可进入）

### 1、光标移动

①光标移动到行首
　　按键：shift + 6 或 ^（T字母上面的6，不要按小键盘的6）
　　②光标移动到行尾
　　按键：shift + 4 或 $（R字母的左上角的4，不是小键盘的4）
　　③光标移动到首行行首
　　按键：gg
　　④光标移动到末行行首
　　按键：G
　　⑤翻屏
　　向上翻屏：按键ctrl + b   （before）或 PgUp
　　向下翻屏：按键ctrl + f   （after）或PgDn



### 2、复制操作

①复制光标所在行
　　按键：yy
　　粘贴：在想要粘贴的地方按下p键
　　**②以光标所在行为准（包含当前行），向下复制指定的行数**
　　按键：数字y
　　③**可视化**复制
　　按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑↓←→方向键来选中需要复制的区块，按下y键进行复制，最后按下p键粘贴

### 3、剪切/删除

**①剪切/删除光标所在行**
　　按键：dd（删除之后下一行上移）
　　注意：dd严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。
　　**②剪切/删除光标所在行为准（包含当前行），向下删除/剪切指定的行**
　　按键：数字dd（删除之后下一行上移）
　　③剪切/删除光标所在的当前行之后的内容，但是删除之后下一行不上移
　　按键：D（删除之后当前行会变成空白行）
　　④可视化删除
　　按键：ctrl + v（可视块）或V（可视行）或v（可视），上下左右移动，按下D表示删除选中行，d表示删选中块

### 4、撤销/恢复

       **撤销：输入:u （不属于命令模式）  或者   u（undo）**
　　**恢复：ctrl + r恢复（取消）之前的撤销操作**

### 5、扩展1：光标的快速移动

       **①快速将光标移动到指定的行**
　　按键：数字G
　　**②以当前光标为准向上/向下移动n行**
　　按键：数字↑，数字↓
　　③以当前光标为准向左/向右移动n字符
　　按键：数字←，数字→
　　④末行模式下的快速移动方式：移动到指定的行
　　按键：输入英文“:”，其后输入行数数字，按下回车



## 四、模式间的切换（重点）

## 五、末行模式

进入方式：由命令模式进入，按下“:”或者“/（表示查找）”即可进入
　　退出方式：
　　a. 按下esc
　　b. 连按2次esc键
　　c. 删除末行全部输入字符
　　①保存操作（write）
　　输入：“:w”保存文件
　　输入：“:w  路径”另存为
　　②退出（quit）
　　输入：“:q”退出文件
　　③保存并退出
　　输入：“:wq”保存并且退出
　　④强制 （!）
　　输入：“:q!”表示强制退出，刚才做的修改操作不做保存
　　⑤调用外部命令（了解）
　　输入：“:!外部命令”



例如：

```Bash
:!ls -la/
```

当外部命令执行结束之后按下任意键回到vim编辑器打开的内容



       ⑥搜索/查找
　　       输入：“/关键词”
　　       例如：我想在passwd文件中搜索“sbin”关键词

```Bash
/sbin
```

 **在搜索结果中切换上/下一个结果：N/n（next）**
　　如果需要取消高亮，则需要输入：“:nohl”【no highlight】
　　⑦替换
　　:s/搜索的关键词/新的内容替换光标所在行的第一处符合条件的内容
　　:s/搜索的关键词/新的内容/g替换光标所在行的全部符合条件的内容
　　:%s/搜索的关键词/新的内容替换整个文档中每行第一个符合条件的内容
　　:%s/搜索的关键词/新的内容/g替换整个文档的符合条件的内容
　　%表示整个文件
　　g表示全局（global）
　　⑧显示行号（临时）
　　输入：“***:set nu***”[number]
　　如果想取消显示，则输入：“:set nonu”
　　⑨扩展2：使用vim同时打开多个文件，在末行模式下进行切换文件

**查看当前已经打开的文件名称：“:files”**

```Bash
:files
```

在%a的位置有2种显示可能
　　%a：a=active，表示当前正在打开的文件；
　　#：表示上一个打开的文件
　　切换文件的方式：
　　**：a. 如果需要指定切换文件的名称，则可以输入：“:open 已经打开的文件名”**

```Bash
:open passwd
```

**b. 可以通过其他命令来切换上一个文件/下一个文件**
　　输入：“:bn”切换到下一个文件（back next）
　　输入：“:bp”切换到上一个文件（back prev）



## 六、编辑模式

       i：在光标所在字符前开始插入
　　a：在光标所在字符后开始插人
　　0：在光标所在行的下面另起一新行插入
　　I ：在光标所在行的行首开始插入,如果行首有空格则在空格之后插入
　　A：在光标所在行的行尾开始插人
　　Q：在光标所在行的上面另起一行开始插人
　　S：删除光标所在行并开始插


　　重点看前2个进入方式：i（insert）、a（after）。


　　退出方式：按下esc键



## 七、实用功能

### 1、代码着色

案例：首先创建简单的c语言程序

```C
#include<stdio.h>
void main() {
  printf('helloworld!\n') ；
}
```

如何控制着色显示与否？
　　显示：“:syntax on”       syn
　　tax：语法
　　关闭显示：“:syntax off”



### 2、vim中计算器的使用

当在编辑文件的时候突然需要使用计算器去计算一些公式，则此时需要用计算器，但是需要退出，vim自身集成了一个简易的计算器。
　　a. 进入编辑模式
　　b. 按下按键“ctrl + R”，然后输入“=”，此时光标会变到最后一行
　　c. 输入需要计算的内容，按下回车



## 八、扩展（3）

### 1、vim的配置（重点）

Vim是一款编辑器，编辑器也是有配置文件的。
　　Vim配置有三种情况：
　　a. 在文件打开的时候在末行模式下输入的配置（临时的）
　　b. 个人配置文件（~/.vimrc，如果没有可以自行新建）
　　c. 全局配置文件（vim自带，/etc/vimrc）
　　①新建好个人配置文件之后进入编辑
　　②在配置文件中进行配置



比如显示行号：set nu

```Bash
set nu
```

配置好之后vim打开文件就会永远显示行号
　　**如果针对同一个配置项，个人配置文件中存在，则以个人配置文件为准，如果个人配置文件中不存在这一项，则以全局配置文件为准**。

### 2、异常退出

什么是异常退出：在编辑文件之后并没有正常的去wq（保存退出），而是遇到突然关闭终端或者断电的情况，，这个情况称之为异常退出：
　　解决办法：将交换文件（在编程过程中产生的临时文件）删除掉即可
　　#rm  -f .passwd.swp

### 3、别名机制（实用）

作用：相当于创建一些属于自己的自定义命令
　　例如：在windows下有cls命令，在Linux下可能因为没有这个命令而不习惯清屏。现在可以通过别名机制来解决这个问题，可以自己创造出cls命令
　　别名机制依靠一个别名映射文件：~/.bashrc，在文件下添加以下命令



```Bash
vim  ~/.bashrc

alias cls = 'clear'
```

**注意：如果想新创造的命令生效，必须要重新登录当前用户。**

### 4、退出方式

回顾：之前vim中退出编辑的文件可以使用“:q”或者“:wq”。
　　**除了上面的这个语法之外，vim还支持另外一个保存退出方法“:x”。**
　　说明：
　　①“:x”在文件没有修改的情况下，表示直接退出，在文件修改的情况下表示保存并退出；
　　②如果文件没有被修改，但是使用wq进行退出的话，则文件的修改时间会被更新；但是如果文件没有被修改，使用x进行退出的话，则文件修改时间不会被更新的；主要是会混淆用户对文件的修改时间的认定。
　　因此建议以后使用“:x”来进行对文件的保存退出。
　　**但是：不要使用X，不要使用X，不要使用X，X表示对文件进行加密操作。**

# 05、Linux自有服务（1）

自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装好之后就可以直接使用的服务（内置）。

## 一、运行模式

运行模式也可以称之为**运行级别**。



在linux中存在一个进程：init （initialize，初始化），进程id是1。

```Bash
ps -ef|grep init
```

该进程存在一个对应的配置文件：inittab（**系统运行级别配置文件**，位置/etc/inittab）



文件的主要内容：

```Bash
# Default runlevel. The runlevels used are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
#
id:3:initdefault:
```

根据上述的描述，可以得知，Centos6.5中存在7种运行级别/模式。
　　0 — 表示关机级别（不要将默认的运行级别设置成这个值）
　　1 — 单用户模式
　　2 — 多用户模式，不带NFS（Network File Syetem）
　　3 — 多用户模式，完全的多用户模式（不带桌面的，纯命令行模式）
　　4 — 没有被使用的模式（被保留模式）
　　5 — X11，完整的图形化界面模式
　　6 — 表示重启级别（不要将默认的运行级别设置成这个值）
　　与该级别相关的几个命令：
　　#init 0表示关机
　　#init 3表示切换到不带桌面的模式
　　#init 5切换到图形界面
　　#init 6 重启电脑
　　注意：init指令需要超级管理员的权限，普通用户无法执行。
　　**这些命令其实都是调用的init进程，将数字（运行级别）传递给进程，进程去读配置文件执行对应的操作。**



①切换到纯命令行模式下（**临时切换，重启之后又恢复**）

```Bash
init 3
```

切换之后需要输入用户名和密码，在**输入密码的时候没有“*”提示输入，只要自己确认输入的密码没有错误，按下回车即可**。



②回到桌面模式

```Bash
init 5
```



**③设置模式永久为命令行模式**

将/etc/inittab文件中的initdefault值设置成3，然后重启操作系统。

## 二、用户与用户组管理（重点）

Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
　　用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。
　　每个用户账号都拥有一个惟一的用户名和各自的密码。
　　用户在登录时键入正确的用户名和密码后，就能够进入系统和自己的主目录。
　　要想实现用户账号的管理，要完成的工作主要有如下几个方面：



用户账号的添加、删除、修改以及用户密码的管理。
　　用户组的管理。



**注意三个文件：**
　　/etc/passwd存储用户的关键信息
　　/etc/group存储用户组的关键信息
　　/etc/shadow存储用户的密码信息

### 1、用户管理

①添加用户
　　常用语法：#useradd 选项 用户名
　　常用选项：
　　-g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名
　　-G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名
　　-u：uid，用户的id（用户的标识符），**系统默认会从500之后按顺序分配uid**，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】
　　-c comment：添加注释
　　-d 自定义用户HOME路径 useradd -d /dsg11/kjw kjw



案例：创建用户zhangsan，不带任何选项 



```Bash
useradd zhangsan
```

验证是否成功：
　　a. 验证/etc/passwd的最后一行，查看是否有zhangsan的信息；
　　b. 验证是否存在家目录（在Centos下创建好用户之后随之产生一个同名家目录）；
　　用户名:密码:用户ID:用户组ID:注释:家目录:解释器shell
　　用户名：创建新用户名称，后期登录的时候需要输入；
　　密码：此密码位置一般情况都是“x”，表示密码的占位；
　　用户ID：用户的识别符；
　　用户组ID：该用户所属的主组ID；
　　注释：解释该用户是做什么用的；
　　家目录：用户登录进入系统之后默认的位置；
　　解释器shell：等待用户进入系统之后，用户输入指令之后，该解释器会收集用户输入的指令，传递给内核处理；


　　**注意：在不添加选项的时候，执行useradd之后会执行一系列的操作**
　　**a. 创建同名的家目录；**
　　**b. 创建同名的用户组；**



案例：添加选项，创建用户lisi，让lisi属于501主组，附加组500，自选靓号666。

```Bash
user -g 501 -G 500 -u 666 lisi
```

**注意：查看用户的主组可以查看passwd文件，查看附加组可以查看group文件。**



②修改用户
　　常用语法：#usermod 选项 用户
　　Usermod：user modify，用户修改
　　常用选项：
　　-g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名
　　-G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名
　　-u：uid，用户的id（用户的标识符），**系统默认会从500之后按顺序分配uid**，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】
　　-l：修改用户名



案例：修改zhangsan用户主组为500，附加组改为501

```Bash
usermod -g 500 -G 501 zhangsan
```



案例：修改zhangsan用户用户名，改为wangerma

**#usermod -l 新的用户名 旧的用户名**

```Bash
usermod -l wangerma zhangsan
```



③设置密码
　　Linux不允许没有密码的用户登录到系统，因此前面创建的用户目前都处于锁定状态，需要设置密码之后才能登录计算机。



**常用语法：#passwd 用户名**
　　案例：设置wangerma用户的密码
　　在设置密码的时候也是没有任何输入提示的，放心输入，确保两次输入的密码一致，按下回车即可。
　　也可以使用弱密码，但是不建议，否则会看到以下的提示：

```Bash
passwd wangerma
```



切换用户命令：#su [用户名]（switch user）su -  用户名  直接切换到对应的根目录下
　　如果用户名不指定则表示切换到root用户。
　　④删除用户
　　常用语法：#userdel 选项 用户名
　　Userdel：user delete（用户删除）
　　常用选项：
　　**-r：表示删除用户的同时，删除其家目录；**
　　案例：删除wangerma用户

```Bash
 userdel wangerma
```

**注意：已经登录的wangerma用户删除的时候提示删除失败，但是没有登录的lisi用户可以正常删除**。
　　解决办法：简单粗暴，kill对应用户的全部进程    kill -9 进程号 强制杀死
　　提示：所有跟用户操作的命令（除passwd外）只有root超级管理员有权限执行。

### 2、用户组管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，**这个用户组在创建用户时同时创建**。
　　用户组的管理涉及用户组的**添加、删除和修改**。组的增加、删除和修改实际上就是对/etc/group文件的更新。
　　文件结构：
　　**用户组名:密码:用户组ID:组内用户名**
　　密码：X表示占位符，虽然用户组可以设置密码，但是绝大部分的情况下不设置密码；
　　组内用户名：表示附加组是该组的用户名称；


　　①用户组添加
　　常用语法：#groupadd 选项 用户组名
　　常用选项：
　　-g：类似用户添加里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字，如果自己不指定，则默认从500之后递增；

案例：使用groupadd指令创建一个新的用户组，命名为Administrators

```Bash
groupadd Administrators
```

②用户组编辑
　　常用语法：#groupmod 选项 用户组名
　　常用选项：
　　-g：类似用户修改里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字
　　-n：类似于用户修改“-l”，表示设置新的用户组的名称
　　案例：修改Administrators用户组，将组ID从502改成520，将名称改为admins

```Bash
groupmod -g 520 -n admin Administrators
```

③用户组删除
　　常用语法：#groupdel 用户组名

```Bash
groupdel zhangsan
```

注意：当如果需要删除一个组，但是**这个组是某个用户的主组时**，则不允许删除；如果确实需要删除，则先从组内移出所有用户。
　　usermod  -g lisi lisi  修改用户的所属组      usermod   -g 用户组   用户名

```Bash
usermod -g 0 Linux123
groupdel Linux123
```

## 三、网络设置

首先知道网卡配置文件位置：/etc/sysconfig/network-scripts

```Bash
ls /etc/sysconfig/network-scripts
    ifcfg

```

在目录中网卡的配置文件命名格式：ifcfg-网卡名称
　　ONBOOT：是否开机启动
　　BOOTPROTO：ip地址分配方式，DHCP表示动态主机分配协议
　　HWADDR：硬件地址，MAC地址
　　需要重启网卡

```Bash
service network restart
```

在有的分支版本中可能没有service命令来快速操作服务，但是有一个共性的目录：/etc/init.d
　　这个目录中放着很对服务的快捷方式。
　　此处重启网卡命令还可以使用：

```Bash
/etc/init.d/network restart
```

**扩展1：**如果修改网卡的配置文件，但是配置文件的目录层次很深，此时可以在浅的目录中创建一个快捷方式（软连接），方便以后去查找
　　**#ln -s 原始文件的路径 快捷方式的路径**
　　通过ls -l可以列出如下的效果：
　　其中，文件类型位置的“l”表示其类型为link（连接类型），后面的“->”指向的是原始文件路径。
　　**扩展2：如何去重启单个网卡？**
　　停止某个网卡：#ifdown 网卡名
　　开启某个网卡：#ifup 网卡名
　　例如：需要停止-启动（重启）eth0网卡，则可以输入
　　#ifdown eth0
　　#ifup eth0
　　**提示：在实际工作的时候不要随意禁网卡。**
　　**如果要设置linux服务器的ip地址，需要找到网卡所在位置**

## 四、ssh服务（重点）

ssh（secure shell，安全外壳协议），该协议有2个常用的作用：**远程连接协议**、远程文件传输协议。



协议使用**端口**号：默认是22
　　可以是被修改的，如果需要修改，则需要修改ssh服务的配置文件：

```Bash
vi /etc/ssh/ssh_config
    Port 22

```

端口号可以修改，但是得注意2个事项：
　　a. 注意范围，端口范围是从0-65535；
　　b. 不能使用别的服务已经占用的端口；



**服务启动/停止/重启**

#service sshd start/stop/restart
　　#/etc/init.d/sshd start/stop/restart

```Bash
/ect/init.d/sshd restart
/etc/init.d/sshd start
/etc/init.d/sshd stop

service sshd start
service sshd stop
service sshd restart

```

# 06、Linux自有服务（2）

自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装好之后就可以直接使用的服务（内置）。

## 一、设置主机名

回顾：
　　#hostname
　　#hostname -fFQDN（全限定域名）
　　①临时设置主机名（立竿见影），需要切换用户使之生效
　　#hostname 设置的主机名

```Bash
hostname yunwei
```

②永久设置主机名（需要重启）
　　先找到一个文件
　　/etc/sysconfig/network【主机名的配置文件】
　　修改其中的HOSTNAME为自己需要设置的永久主机名

```Bash
vi /etc/sysconfig/network

HOSTNAME=yunwei

```



**③修改linux服务器的hosts文件，将yunwei指向本地（设置FQDN）**

Hosts文件的位置：/etc/hosts

```Bash
 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 yunwei
 ::1       localhost localhost.localdomain j localhost61ocalhost6.localdomain6
```



问题：不设置FQDN会怎么样？
　　①很多开源服务器软件（例如Apache）则无法启动，或出现报错；
　　②方便记忆，看到主机名对其作用有一个初步判断；
　　③如果不设置则会影响本地的域名的解析（本地访问）；

## 二、chkconfig

作用：相当于windows下“安全卫士”、“电脑管家”之类的安全辅助工具**提供“开机启动项”的一个管理服务**。
　　在linux下不是所有的软件安装完成之后都有开机启动服务，有的可能需要自己去添加。除此之外还可以查看和删除。



①开机启动**服务查询**

```Bash
chkconfig --list
```

其中0-6表示各个启动级别
　　例如：以httpd为例，其3级别为关闭（off），则表示其在3启动形式下默认开机不启动

```Bash
httpd    0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭  6：关闭
```

5对应的也是关闭，则表示其在桌面环境下也是开机不启动。
　　再例如：kdump服务，在2，3，4，5的级别下默认开机启动的，其他级别下默认开机不启动



②删除服务
　　#chkconfig --del 服务名
　　例如删除httpd服务

```Bash
chkconfig --list | grep httpd
    httpd    0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭  6：关闭
chkconfig --del  httpd
chkconfig --list | grep httpd

```

③添加开机启动服务
　　#chkconfig --add 服务名【必须要保证服务正常运行，才可以添加】

```Bash
chkconfig --add httpd
```



**④设置服务在某个级别下开机启动/不启动【重点命令】**
　　**#chkconfig --level 连在一起的启动级别 服务名on/off**



案例：设置httpd服务在3，5级别下默认开机启动

案例：设置httpd服务在5的级别下默认开机不启动

```Bash
chkconfig --level 35 httpd on
chkconfig --level 5 httpd off

```

## 三、ntp服务

作用：ntp主要是用于**对计算机的时间同步管理**操作。
　　时间是对服务器来说是很重要的，一般很多网站都需要读取服务器时间来记录相关信息，如果时间不准，则可能造成很大的影响。
　　例如：当前虚拟机里的linux时间就是不准确的
　　同时服务器时间方式有2个：**一次性同步（手动同步）、通过服务自动同步**。



上游的概念：

```Mermaid
flowchart LR
      A(自己服务器)-->B(上一别的时间服务器)-->C(上上一级的时间服务器)
     
   C-.->D(根服务器)
```

①一次性同步时间（简单）

**#ntpdate 时间服务器的域名或ip地址**

```Bash
ntpdate 127.0.0.1
```

②设置时间同步服务
　　服务名：ntpd
　　启动ntpd服务
　　#service ntpd start    或者   /etc/init.d/ntpd start

```Bash
service ntod start
```

设置ntpd服务开机启动：

```Bash
 chkconfig --list|grep ntpd
  chkconfig --level 35 ntpd on
```

## 四、防火墙服务

防火墙：**防范一些网络攻击**。有**软件防火墙**、硬件防火墙之分。
　　防火墙选择让请求通过，从而保证网络安全性。
　　**在当前的centos6.5中防火墙有一个名称：iptables** 【7.x中默认使用的是firewalld】
　　①查看iptables是否开机启动

```Bash
chkconfig --list | grep iptables 
```



②iptables服务启动/重启/关闭

```Bash
service iptables start/restart/stop
/etc/init.d/iptables start /restart/stop

```



**③查看iptables的状态（规则）**

```Bash
service iptables status
```



如果iptables没有启动，则提示服务没启动，如果已经启动，则显示防火墙的相关的规则信息
　　④查看规则的命令
　　#iptables -L -n
　　含义：
　　-L：表示列出规则
　　-n：表示将单词表达形式改成数字形式显示
　　⑤简单设置防火墙规则
　　例如，需要允许80端口通过防火墙，则规则可以用以下的命令来设置

```Bash
**iptables -I INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口**
```

Iptables：主命令
　　-I：表示将规则放到最前面
　　-A：add，添加规则（最后）
　　INPUT：进站请求【出站output】
　　-p：protocol，指定协议（icmp/tcp/udp）
　　--dport：指定端口号
　　-j：指定行为结果，允许（accept）/禁止（reject）/丢弃（drop）



添加完成之后需要保存操作：

**/etc/init.d/iptables save**

service iptables start #开启systemctl enable iptables.service #设置防火墙开机启动



如果是centos7版本的话:

firewall-cmd?--zone=public?--permanent?--add-port=8010/tcp
　　??systemctl enable firewalld.service中间间隔?systemctl restart firewalld.service
　　?firewall-cmd –state 查看防火墙状态
　　centos7下设置开机自动启动
　　systemctl enable 服务名.service  设置开机自动启动
　　systemctl start  服务名.service   启动服务

# 添加开机自启脚本

在centos7中增加脚本常用方法，以脚本starttomcat.shs为例
　　脚本中代码是:

```Bash
　　#!/bin/bash
　　# description:开机自启脚本
　　/usr/local/tomcat/bin/startup.sh  #启动tomcat
　　方法一：
　　将脚本移动到/etc/rc.d/init.d目录下
　　mv   /opt/script/starttomcat.sh  /etc/rc.d/init.d
　　增加脚本的可执行权限
　　Chmod  +x    /etc/rc.d/init.d/starttomcat.sh
　　添加脚本到开机自动启动项目中
　　cd  /etc/rc.d/init.d
　　chkconfig   --add  starttomcat.sh
　　chkconfig   starttomcat.sh  on
```

**测试服务器端端口是否开通**
　　首先在自己电脑上-控制面板-程序-程序和功能-打开或者关闭windows功能-选择telnet服务器-telent客户端
　　然后cmd命令
　　telnet  服务器ip地址   端口号 测试有反应则是开通的

## 五、rpm管理（重点）

作用：rpm的作用类似于windows上的电脑管家中“软件管理”、安全卫士里面“软件管家”等产品，主要作用是对linux服务器上的软件包进行对应管理操作，**管理分为：查询、卸载、安装**。



①查询某个软件的安装情况

**#rpm -qa|grep 关键词**

选项：

	-q：查询，query

	-a：全部，all



案例：查询linux上是否安装某个软件

```Bash
rmp -qa | grep 软件名

```

②卸载某个软件

```Bash
rpm -e 软件名
```

注意：
　　火狐卸载的时候是没有依赖关系的，所以可以直接卸载。
　　但是在卸载Apache的时候提示无法卸载
　　当存在依赖关系的时候又不想去解决这个问题的时候可以：

```Bash
rpm -e 软件包名 --nodeps
```



③软件的安装
　　要想装软件，和windows下一样，先得找到安装包。
　　软件包的获得方式：
　　a. 去官网去下载；
　　b. 不介意老版本的话，可以从光盘（或者镜像文件）中读取；
　　此处以光盘文件为例：
　　**查看块状设备的信息：**
　　#lsblk   （list block devices）查看块状设备的信息

```Bash
　　┌──(root?hello)-[~]
　　└─# lsblk
　　NAME  MAJ:MIN  RM   SIZE  RO  TYPE  MOUNTPOINTS
　　sda     8:0     0   256G   0  disk
　　sdb     8:16    0   256G   0  disk /
```

Name：名称
　　Size：设备大小
　　Type：类型
　　MountPoint：挂载点（类似windows下盘符）



**扩展：光盘的挂载和解挂**

a. 解挂操作
　　命令：umount
　　**语法：#umount 当前设备的挂载点（路径）**

此时，相当于U盘在windows上已经被弹出了，但是没有拔下电脑USB接口。



b. 挂载光盘
　　命令：mount
　　**语法：#mount 设备原始地址 要挂载的位置路径**
　　设备原始地址：地址统一都在/dev下，然后根据大小确定具体name值，拼凑在一起组成原始地址，例如当前：“/dev/sr0”
　　要挂载的位置路径：挂载目录一般都在mnt下，也可以在mnt下建目录，此处以“/mnt/dvd”为例



**安装软件的命令：**

**#rpm -ivh 软件包完整名称**

选项：
　　-i：install，安装
　　-v：显示进度条
　　-h：表示以“#”形式显示进度条



## 六、cron/crontab计划任务（重点）

作用：操作系统不可能24小时都有人在操作，有些时候想在指定的时间点去执行任务（例如：每天夜里2点去重新启动Apache），此时不可能真有人每天夜里2点去执行命令，此时可以交给计划任务程序去执行操作。



语法：#crontab 选项
　　常用选项：
　　******-l：list，列出指定用户的计划任务列表**
　　**-e：edit，编辑指定用户的计划任务列表**
　　-u：user，指定的用户名，如果不指定，则表示当前用户
　　-r：remove，删除指定用户的计划任务列表



**②编辑计划任务（重点）**
　　计划任务的规则语法格式，以行为单位，一行则为一个计划：
　　分 时 日 月 周 需要执行的命令
　　例如：如果想要每天的0点0分执行reboot指令，则可以写成

```Bash
0 0 * * * reboot
```



**取值范围：**
　　分：0~59
　　时：0~23
　　日：1~31
　　月：1~12
　　周：0~7，0和7表示星期天

**四个符号：**

,：这里指的是在两个以上的时间点中都执行，如果我们在 “分” 这个域中定义为 8,12,35 ，则表示分别在第8分，第12分 第35分执行该定时任务。

-：这个比较好理解就是指定在某个域的连续范围，如果我们在 “时” 这个域中定义 1-6，则表示在1到6点之间每小时都触发一次，用 , 表示 1,2,3,4,5,6

*：表示所有值，可解读为 “每”。 如果在“日”这个域中设置 *,表示每一天都会触发。

?：表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的8号触发一个操作，但不关心是周几，我们可以这么设置 0 0 0 8 * ?

/：在某个域上周期性触发，该符号将其所在域中的表达式分为两个部分，其中第一部分是起始值，除了秒以外都会降低一个单位，比如 在 “秒” 上定义 5/10 

  表示从 第 5 秒开始 每 10 秒执行一次，而在 “分” 上则表示从 第 5 秒开始 每 10 分钟执行一次。

L：表示英文中的LAST 的意思，只能在 “日”和“周”中使用。在“日”中设置，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在“周”上表示周六，

  相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在“周”上设置”7L”这样的格式,则表示“本月最后一个周六”

W：表示离指定日期的最近那个工作日(周一至周五)触发，只能在 “日” 中使用且只能用在具体的数字之后。若在“日”上置”15W”，表示离每月15号最近的那个工作日触发。

  假如15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。

  如果是 “1W” 就只能往本月的下一个最近的工作日推不能跨月往上一个月推。

#：表示每月的第几个周几，只能作用于 “周” 上。例如 ”2#3” 表示在每月的第三个周二。


问题1：每月1、10、22日的4:45重启network服务

```Bash
45  4  1,10,22  *  *  service network restart
```

问题2：每周六、周日的1:10重启network服务

```Bash
10  1  *  *  6,0   service network restart
```

问题3：每天18:00至23:00之间每隔30分钟重启network服务

```Bash
*/30  18-23  *  *  *   service network restart
```

问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启

```Bash
3,15  8-11  */2  *  *   reboot
```



**看看服务有没有打开**

**service  crond  status**

案例：真实测试案例，每1分钟往root家目录中的RT.txt中输入当前的时间信息，为了看到效果使用追加输出

```Bash
*/1  *   *   *   *  ls ~>> /root/RT.txt
```

**Crontab权限问题：本身是任何用户都可以创建自己的计划任务**。

但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 ：
　　配置文件位于（黑名单）：
　　/etc/cron.deny里面写用户名，一行一个

还有一个配置文件：（白名单）
　　/etc/cron.allow（本身不存在，自己创建）

**注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。**







# 07、Linux的权限管理操作 

**Linux的权限操作与用户、用户组是兄弟操作。**

## 一、权限概述

总述：Linux系统一般将文件可存/取访问的身份分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。

### 1、权限介绍

什么是权限？
　　在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用或存储量的限制。
　　在Linux中分别有读、写、执行权限：


　　读权限：
　　对于文件夹来说，读权限影响用户是否能够列出目录结构
　　对于文件来说，读权限影响用户是否可以查看文件内容


　　写权限：
　　对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档
　　对于文件来说，写权限影响用户是否可以编辑文件内容


　　执行权限：
　　一般都是对于文件来说，特别脚本文件。

### 2、身份介绍

#### Owner身份（文件所有者，默认为文档的创建者）

由于Linux是多用户、多任务的操作系统，因此可能常常有多人同时在某台主机上工作，但每个人均可在主机上设置文件的权限，让其成为个人的“私密文件”，即个人所有者。因为设置了适当的文件权限，除本人（文件所有者）之外的用户无法查看文件内容。



例如某个MM给你发了一封Email情书，你将情书转为文件之后存档在自己的主文件夹中。为了不让别人看到情书的内容，你就能利用所有者的身份去设置文件的适当权限，这样，即使你的情敌想偷看你的情书内容也是做不到的。

#### Group身份（与文件所有者同组的用户）

与文件所有者同组最有用的功能就体现在**多个团队在同一台主机上开发资源的时候**。例如主机上有A、B两个团体，A中有a1,a2,a3三个成员，B中有b1,b2两个成员，这两个团体要共同完成一份报告F。由于设置了适当的权限，A、B团体中的成员都能互相修改对方的数据，但是团体C的成员则不能修改F的内容，甚至连查看的权限都没有。同时，团体的成员也能设置自己的私密文件，让团队的其它成员也读取不了文件数据。**在Linux中，每个账户支持多个用户组。如用户a1、b1即可属于A用户组，也能属于B用户组【主组和附加组】**。

#### Others身份（其他人，相对于所有者）

这个是个相对概念。打个比方，大明、二明、小明一家三兄弟住在一间房，房产证上的登记者是大明（owner所有者），那么，大明一家就是一个用户组，这个组有大明、二明、小明三个成员；另外有个人叫张三，和他们三没有关系，那么这个张三就是其他人了。

同时，大明、二明、小明有各自的房间，三者虽然能自由进出各自的房间，但是小明不能让大明看到自己的情书、日记等，这就是文件所有者（用户）的意义。

#### Root用户（超级用户）

在Linux中，还有一个神一样存在的用户，这就是root用户，因为在所有用户中它拥有最大的权限 ，所以管理着普通用户。

### 3、Linux的权限介绍

要设置权限，就需要知道文件的一些基本属性和权限的分配规则。在Linux中，ls命令常用来查看文件的属性，用于显示文件的文件名和相关属性。

#ls -l 路径		【ls -l  等价于 ll】

**Linux中存在用户、用户组和其他人概念**，各自有不同的权限，对于一个文档来说，其权限具体分配如下：

```Bash
d rwx r-x ---

d：文件类型    rwx：文件所有者权限    r-x：文件所属组权限    ---：其他人对于这个文件的权限

r：read，可读            w：write，可写            e：execute，可执行            -：没有对应权限
```



十位字符表示含义：
　　第1位：表示文档类型，取值常见的有“d表示文件夹”、“-表示文件”、“l表示软连接”、“s表示套接字”等等；
　　第2-4位：表示文档所有者的权限情况，第2位表示读权限的情况，取值有r、-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x、-。
　　第5-7位：表示与所有者同在一个组的用户的权限情况，第5位表示读权限的情况，取值有r、-；第6位表示写权限的情况，w表示可写，-表示不可写，第7位表示执行权限的情况，取值有x、-。
　　第8-10位：表示除了上面的前2部分的用户之外的其他用户的权限情况，第8位表示读权限的情况，取值有r、-；第9位表示写权限的情况，w表示可写，-表示不可写，第10位表示执行权限的情况，取值有x、-。

权限分配中,均是rwx的三个参数组合，**且位置顺序不会变化**。没有对应权限就用 – 代替。

## 二、权限设置

**语法：#chmod 选项 权限模式 文档**
　　常用选项：
　　-R：递归设置权限（当文档类型为文件夹的时候）
　　权限模式：就是该文档需要设置的权限信息
　　文档：可以是文件，也可以是文件夹，可以是相对路径也可以是绝对路径。
　　**注意点：如果想要给文档设置权限，操作者要么是root用户，要么就是文档的所有者。**



### 1、字母形式

||||
|-|-|-|
|选项|字母|介绍|
|谁|u|关联用户|
|谁|g|用户组|
|谁|o|其他人|
|谁|a|所有人|
|作用|+|增加权限|
|作用|-|减少权限|
|作用|=|确定权限|
|权限|r|可读|
|权限|w|可写|
|权限|x|执行|


给谁设置：
　　u：表示所有者身份owner（user）
　　g：表示给所有者同组用户设置（group）
　　o：表示others，给其他用户设置权限
　　a：表示all，给所有人（包含ugo部分）设置权限
　　**如果在设置权限的时候不指定给谁设置，则默认给所有用户设置**

权限字符：
　　r：读
　　w：写
　　x：表示执行
　　-：表示没有权限

权限分配方式：
　　+：表示给具体的用户新增权限（相对当前）
　　-：表示删除用户的权限（相对当前）
　　=：表示将权限设置成具体的值（注重结果）【赋值】



如果有两部分权限一样则可以合在一起写的：

```Bash
chmod ug=rwx  
```



**例如：如果anaconda-ks.cfg文件什么权限都没有，可以使用root用户设置所有人都有执行权限，则可以写成**

```Bash
chmod  +x  anaconda-ks.cfg      #所有用户赋予执行权限
chmod  a=x  anaconda-ks.cfg     #给所有用户只赋予执行权限
chmod  a+x  anaconda-ks.cfg     #给所有用户添加执行权限

```

### 2、数字形式

经常会在一些技术性的网页上看到类似于**#chmod  777  a.txt**  这样的一个权限，这种形式称之为数字形式权限（777）。

**读：        r                      4**

**写：       w	      	      2**

**执行：    x		      1**

没有任何权限：0

||||
|-|-|-|
|数值|权限|目录列表|
|0|不能读，不能写，不能执行|---|
|1|不能读，不能写，可执行|--x|
|2|不能读，可写，不能执行|-w-|
|3|不能写，可写，可执行|-wx|
|4|可读，不能写，不能执行|r--|
|5|可读，不能写，可执行|r-w|
|6|可读，可写，不能执行|rw-|
|7|可读，可写，可执行|rwx|


例：

```Bash
chmod 755  a.txt
```


　　代表当前文件的拥有者具有可读可写可执行
　　代表当前文件拥有者同一个组的用户对其可读可执行
　　其他用户可读可执行

**在Linux中，如果要删除一个文件，不是看文件有没有对应的权限，而是看****文件所在的目录是否有写权限****，如果有才可以删除**。 

## 三、属主与属组设置

属主：所属的用户（文件的主人）

属组：所属的用户组

```Bash
drwx------   2 root root   16384 2019年 4月11日 lost+found
drwxr-xr-x   2 root root    4096  3月12日 08:00 media
drwxr-xr-x   5 root root    4096  5月10日 10:17 mnt
drwxr-xr-x   2 root root    4096  3月12日 08:00 opt
dr-xr-xr-x 342 root root       0  6月 5日 11:17 proc
drwx------   5 root root    4096  5月19日 17:40 root
drwxr-xr-x   6 root root     120  6月 5日 11:17 run
               用户 用户组
```

这两项信息在文档创建的时候会使用创建者的信息（用户名、用户所属的主组名称）。

如果有时候去删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改。

### 1、chown（重点）

**作用：更改文档的所属用户**

语法：#chown  -R  username 文档路径 **要修改目录以及目录内部的文件　加上-R**



案例：将root用户创建的oo目录，所有者更改为kali

```Bash
┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 root root 2  6月 5日 11:40 oo

┌──(root㉿hello)-[/home/kali/Desktop]
└─# chown kali oo

┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 kali root 2  6月 5日 11:40 oo

```

### 2、chgrp

**作用：更改文档的所属用户组**

语法：#chgrp  -R  groupname  文档的路径

案例：将root用户创建的oo目录，将所属用户组改为kali

```Bash
┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 kali root 2  6月 5日 11:40 oo

┌──(root㉿hello)-[/home/kali/Desktop]
└─# chgrp kali oo

┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 kali kali 2  6月 5日 11:40 oo

```





**思考，如何通过一个命令实现既可以更改所属的用户，也可以修改所属的用户组呢？**

答：可以实现的，通过chown命令

	语法：#chown  -R  username:groupname   文档路径

案例：要求只使用chown指令，将ot目录的所属用户和用户组改为kali，并且包含其子目录

```Bash
┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 kali kali    2  6月 5日 11:40 oo
drwxr-xr-x 2 root root 4096  6月 5日 11:52 ot

┌──(root㉿hello)-[/home/kali/Desktop]
└─# chown -R kali:kali ot

┌──(root㉿hello)-[/home/kali/Desktop]
└─# ll
-rw-r--r-- 1 kali kali    2  6月 5日 11:40 oo
drwxr-xr-x 2 kali kali 4096  6月 5日 11:52 ot
```

## 四、sudo

**sudo（switch user do）命令来进行权限设置。sudo可以让管理员（root）事先定义某些特殊命令谁可以执行**。

默认sudo中是没有除root之外用户的规则，要想使用则先**配置**sudo。

**Sudo配置文件：/etc/sudoers**

```Bash
cd　/etc      #查看sudoers这个文件的权限默认是只有读的权限
chmod　u+w   /etc/sudoers    #赋值写权限
vim   /etc/sudoers       #打开sudoers
搜索/root
############################################################################################################################################################
# Cmnd alias specification

# User privilege specification
root    ALL=(ALL) ALL
  
  #Root表示用户名，如果是用户组，则可以写成“%组名”
  #ALL：表示允许登录的主机（地址白名单）
  #(ALL)：表示以谁的身份执行，ALL表示root身份
  #ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割
  
kali ALL=(ALL) ALL   #将kali用户配置在sudoers文件中         

# Allow members of group sudo to execute any command
############################################################################################################################################################

```



**案例：本身test用户不能添加用户，要求使用sudo配置，将其设置为可以****添加用户****，并且可以****修改密码****（****但是不能修改root用户密码****）。**

注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。

路径可以使用which命令来查看

语法：#which 指令名称

```Bash
┌──(root㉿hello)-[~]
└─# which ls
/usr/bin/ls

┌──(root㉿hello)-[~]
└─# which vim
/usr/bin/vim
```

**在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码**。

特别注意：此处按照案例要求，不能让kali用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：

**禁止修改root密码的配置（****先允许全部，再拒绝root密码设置****）：** /usr/bin/passwd [A-Za-z]*, **!/usr/bin/passwd root**

```Bash
kali ALL=(ALL) /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
```

![](https://secure2.wostatic.cn/static/f2HCsFRX83uivBkag4mpCh/image_262.png?auth_key=1698895896-xaubdxPPp6NBBF9ARHcT4Q-0-f31ace7a00072b2f48266c4b92cba001)



在普通用户下怎么查看自己具有哪些特殊权限

**#sudo  -l**

```Bash
┌──(root㉿hello)-[~]
└─# sudo -l
匹配 %2$s 上 %1$s 的默认条目：
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin, use_pty

用户 root 可以在 hello 上运行以下命令：
    (ALL : ALL) ALL

┌──(root㉿hello)-[~]
└─# su kali
┌──(kali㉿hello)-[/root]
└─$ sudo -l
匹配 %2$s 上 %1$s 的默认条目：
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin, use_pty

用户 kali 可以在 hello 上运行以下命令：
    (ALL : ALL) ALL
    (root) NOPASSWD: /usr/lib/win-kex/xrdp/xrdpservice
    (root) NOPASSWD: /usr/lib/win-kex/wslg-sock/wslg-sock

```

最后：sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。

# 08、Linux的网络基础 

## 一、网络相关概述



IP是英文Internet Protocol的缩写，意思是“网络之间互连的协议”，也就是为计算机网络相互连接进行通信而设计的**协议**。

**IP地址类型分为：****公有地址、私有地址****。**

公有地址：

  公有地址（Public address）由Inter NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。

**私有地址（重点）**

私有地址（Private address）属于**非注册地址**，专门为组织机构内部使用。以下列出留用的内部私有地址： 

A类 10.0.0.0--10.255.255.255

B类 172.16.0.0--172.31.255.255

**C类 192.168.0.0--192.168.255.255**

**IP地址按类型可以分为三类：**

|类别 |最大网络数 |IP地址范围 |最大主机数 |私有IP地址范围 |
|-|-|-|-|-|
|A |126（2^7-2) |1.0.0.0-127.255.255.255 |16777214 |10.0.0.0-10.255.255.255 |
|B |16384(2^14) |128.0.0.0-191.255.255.255 |65534 |172.16.0.0-172.31.255.255 |
|C |2097152(2^21) |192.0.0.0-223.255.255.255 |254 |192.168.0.0-192.168.255.255|


网络运维相关技能：ip分类、**子网划分**、划分vlan、ACL、综合布线、各种Serve的搭建。

127.0.0.1			本机ip

### 1、网卡



![](https://secure2.wostatic.cn/static/9veyH4H2GV78icXNmTkRKM/image_265.png?auth_key=1698895896-eVNMLZ66348E8KAHExJ24m-0-f4e35b28bd8f8eb0775b1a7aa70db7bf)

网卡是一个网络组件，属于硬件范畴，主要负责计算机之间数据的**封装和解封**。

MAC地址：网卡的物理地址，网卡设备的编号，**默认**情况是全球唯一的（16进制）。

```Bash
┌──(kali㉿hello)-[/root]
└─$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.227.65  netmask 255.255.240.0  broadcast 192.168.239.255
        inet6 fe80::215:5dff:fe48:3710  prefixlen 64  scopeid 0x20<link>
        ether 00:15:5d:48:37:10  txqueuelen 1000  (Ethernet)
        RX packets 4013  bytes 612066 (597.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15  bytes 1146 (1.1 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

**与IP地址的区别：**

- 长度不同。IP地址为32位，MAC地址为48位。
- 分配依据不同。
- **网络寻址方式不同**。OSI参考模型，ip地址是基于第三层工作（网络层），mac地址是第二层（数据链路层）

### 2、拓扑结构图（扩展）

所谓“拓扑”就是把实体抽象成与其大小、形状无关的“点”，而把连接实体的线路抽象成“线”，进而以图的形式来表示这些点与线之间关系的方法，**其目的在于研究这些点、线之间的相连关系**。表示点和线之间关系的图被称为拓扑结构图。

常见的几种拓扑结构图：

![](https://secure2.wostatic.cn/static/8UyJuAEvgCtSeN258821rf/image_271.png?auth_key=1698895896-5B1un1PwPzUqJpun893pm-0-51d4875bef4212d13c3efbafe95c2e7c)

    

![](https://secure2.wostatic.cn/static/fNoPhqwQ4iaPbj2KX3fY3J/image_272.png?auth_key=1698895896-dzLZVYpuEgAWdQMLvg4wP6-0-f4a906f9c75f553dd54b438d6604f1e7)

![](https://secure2.wostatic.cn/static/cWjAWVizrSWG2SsPZ9NAap/image_273.png?auth_key=1698895896-n9No4Cn3hRzgheY1nt5Mwv-0-672507185088e793047356e917588978)

                   

![](https://secure2.wostatic.cn/static/ktfYY1tKQGDokJ5Unpg7dA/image_274.png?auth_key=1698895896-wminik6FmJLX5aNpo86iwx-0-8e67052a4fd9fa446b6e2648181c6b16)

![](https://secure2.wostatic.cn/static/gqiS1f4q2qsB23Gx9n6UJ2/image_275.png?auth_key=1698895897-dwULJ4Qizf1bwjzBMWLoxw-0-38cd4c373a8c315aaee0c1a4d5236532)

![](https://secure2.wostatic.cn/static/9qa3fYA8K8fo2XoQkRhM1N/image_276.png?auth_key=1698895896-pr76S5TBLNhYTTChGL4b3C-0-1d4c192d2f9538d6dceb497bcce4ce5b)

![](https://secure2.wostatic.cn/static/gRASyBjpiXq934GhrSagWA/image_277.png?auth_key=1698895896-5nVhbiyNts5my1RhcpH8rP-0-a3657fd671394e0ef82d2f4966254b5c)

## 二、网络相关命令

### 1、ping

**作用：检测当前主机与目标主机之间的连通性**（不是100%准确，有的服务器是禁ping）

语法：#ping 主机地址（ip地址、主机名、域名等）



例如：测试和baidu.com之间的连通性。

```Bash
┌──(kali㉿hello)-[~]
└─$ ping www.baidu.com
PING www.a.shifen.com (110.242.68.3) 56(84) bytes of data.
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=1 ttl=52 time=22.6 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=2 ttl=52 time=18.2 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=3 ttl=52 time=18.2 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=4 ttl=52 time=18.2 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=5 ttl=52 time=19.1 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=6 ttl=52 time=18.5 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=7 ttl=52 time=18.7 ms
64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=8 ttl=52 time=18.0 ms
^C64 bytes from 110.242.68.3: icmp_seq=9 ttl=52 time=18.3 ms

--- www.a.shifen.com ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 8295ms
rtt min/avg/max/mdev = 17.972/18.855/22.587/1.360 ms
```

### 2、netstat

**作用：表示查看网络的连接信息**

语法：**#netstat  -tnlp	**	（-t：tcp协议，-n：将字母转化成数字，-l：列出状态为监听，-p：显示进程相关信息）

	  #netstat  -an		（-a：表示全部，-n：将字母转化为数字）



TCP/IP协议需要使用这个命令。

### 3、traceroute

**作用：查找当前主机与目标主机之间所有的网关**（路由器，会给沿途各个路由器发送icmp数据包，路由器可能会不给响应）。

该命令不是内置命令，需要安装，但是目前的已经安装好了（之前选了开发工具）。

语法：#traceroute  主机地址

```Bash
┌──(kali㉿hello)-[~]
└─$ traceroute www.baidu.com
traceroute to www.baidu.com (110.242.68.4), 30 hops max, 60 byte packets
 1  hello.mshome.net (192.168.224.1)  0.223 ms  0.192 ms  0.170 ms
 2  XiaoQiang (192.168.31.1)  1.627 ms  1.617 ms  1.609 ms
 3  192.168.1.1 (192.168.1.1)  3.157 ms  3.154 ms  1.603 ms
 4  100.64.0.1 (100.64.0.1)  5.866 ms  5.613 ms  6.604 ms
 5  hn.kd.pix (219.155.45.53)  8.460 ms hn.kd.ny.adsl (42.228.63.237)  5.508 ms hn.kd.dhcp (61.52.136.101)  5.576 ms
 6  * * pc133.zz.ha.cn (61.168.30.133)  35.533 ms
 7  * * *
 8  110.242.66.174 (110.242.66.174)  20.475 ms 110.242.66.170 (110.242.66.170)  19.617 ms 110.242.66.162 (110.242.66.162)  22.912 ms
 9  221.194.45.130 (221.194.45.130)  22.973 ms  19.668 ms 221.194.45.134 (221.194.45.134)  34.599 ms
10  * * *
```

类似于查看快递的跟踪路由

扩展：在windows下也有类似的命令：tracert  主机地址

```Bash
C:\Users\11395>tracert  www.baidu.com

通过最多 30 个跃点跟踪
到 www.baidu.com [110.242.68.3] 的路由:

  1     1 ms     1 ms     1 ms  XiaoQiang [192.168.31.1]
  2     2 ms     1 ms     1 ms  192.168.1.1 [192.168.1.1]
  3    11 ms    14 ms    14 ms  100.64.0.1
  4     *        *        *     请求超时。
```

### 4、arp

地址解析协议，即ARP（Address Resolution Protocol），是**根据IP地址获取（MAC）物理地址的协议**。



![](https://secure2.wostatic.cn/static/hpYs2U23PsvQG9n71ARoVL/image_283.png?auth_key=1698895897-bgD4RKUwzraf7zNSKHGx8P-0-acb8515fc5c0d8cc6754f3b66a83897f)

**当一个主机发送数据时，首先查看本机MAC地址缓存中有没有目标主机的MAC地址， 如果有就使用缓存中的结果；如果没有，ARP协议就会发出一个广播包，该广播包要求查询目标主机IP地址对应的MAC地址，拥有该IP地址的主机会发出回应，回应中包括了目标主机的MAC地址，这样发送方就得到了目标主机的MAC地址。如果目标主机不在本地子网中，则ARP解析到的MAC地址是默认网关的MAC地址**。



常用语法：#arp -a		查看本地缓存mac表

		  #arp -d 主机地址			删除指定的缓存记录

```Bash
┌──(kali㉿hello)-[~]
└─$ arp -a
hello.mshome.net (192.168.224.1) at 00:15:5d:ee:3a:6a [ether] on eth0
```



该命令在windows下同样适用。

### 5、tcpdump(了解)

作用：抓包，抓取数据表

常用语法：

	#tcpdump 协议 port 端口

	#tcpdump 协议 port 端口 host 地址

	#tcpdump -i 网卡设备名

## 三、防火墙

## 一

### 二、查看防火墙状态

  #### 1、systemctl命令

  可以使用 `systemctl status firewalld` 命令来查看当前防火墙的启动状态。

```Bash
systemctl status firewalld
```

  `Systemctl`是`systemd`的主要命令行工具之一，用于管理系统服务，包括启动、停止、重新启动、重载、启用、禁用、查询服务状态以及查看服务日志等功能

  `status`是`systemd`的一个子命令，可以用于查看系统服务的状态。

  `firewalld`服务的状态

  ---

  该命令一般正常反馈会出现两种状态，分别是：

  启动状态：

  Active：active (running) 表示防火墙为启动状态

```Bash
┌──(root㉿instance-esl8gcnw)-[~]
└─$ systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon    
  #火墙服务 - firewalld - 动态防火墙守护程序
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
     #已加载：已加载（/usr/lib/systemd/system/firewalld.service；禁用；厂商预设：启用）
   Active: active (running) since Thu 2023-06-08 10:58:47 CST; 8s ago
     #活动：自2023-06-08 10:58:47 CST起活动（运行）；8秒前
     Docs: man:firewalld(1)
       #文档: man:firewalld(1)
 Main PID: 3266316 (firewalld)
   #主PID: 3266316 (firewalld)
    Tasks: 2 (limit: 24868)
      #任务: 2 (限制: 24868)
   Memory: 34.8M
     #内存： 34.8M
   CGroup: /system.slice/firewalld.service
     #CG组： /system.slice/firewalld.service
           └─3266316 /usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid

Jun 08 10:58:47 instance-esl8gcnw systemd[1]: Starting firewalld - dynamic firewall daemon...
  #Jun 08 10:58:47 instance-esl8gcnw systemd[1]： 启动 firewalld - 动态防火墙守护程序...
Jun 08 10:58:47 instance-esl8gcnw systemd[1]: Started firewalld - dynamic firewall daemon.\
  #Jun 08 10:58:47 instance-esl8gcnw systemd[1]： 启动 firewalld - 动态防火墙守护进程。


```

  停止状态：

   Active: inactive (dead) 表示防火墙为停止状态

```Bash
┌──(root㉿instance-esl8gcnw)-[~]
└─$ systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
  #● firewalld.service - firewalld - 动态防火墙守护程序
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
     #已加载：已加载（/usr/lib/systemd/system/firewalld.service；禁用；厂商预设：启用）
   Active: inactive (dead)
     #活动：不活动（死）。
     Docs: man:firewalld(1)
       #文档： man:firewalld(1)

Jun 08 10:58:47 instance-esl8gcnw systemd[1]: Starting firewalld - dynamic firewall daemon...
  #Jun 08 10:58:47 instance-esl8gcnw systemd[1]： 启动 firewalld - 动态防火墙守护程序...
Jun 08 10:58:47 instance-esl8gcnw systemd[1]: Started firewalld - dynamic firewall daemon.
  #Jun 08 10:58:47 instance-esl8gcnw systemd[1]： 启动 firewalld - 动态防火墙守护进程。

```

#### 2、firewall-cmd命令

  用于配置 Firewalld 防火墙，使用 `firewall-cmd --state` 命令可以查看当前防火墙的状态。

```Bash
firewall-cmd --state
```

  该命令一般正常反馈会出现两种状态，分别是：

  启动状态：

```Bash
running
```

  停止状态:

```Bash
not running

```

## 三、启动防火墙



